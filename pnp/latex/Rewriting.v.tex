\begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}

\chapter{Equality and Rewriting Principles}
\label{ch:eqrew}



In the previous chapter we have seen how main connectives from
propositional logic are encoded in Coq. However, the mathematical
reasoning only by means of propositional logic is still quite
limited. In particular, by this moment we are still unable to state
what does it mean for two objects to be \textit{equal}. In this chapter we
are going to see how equality can be implemented in Coq. Moreover, the
statement "\textit{x} is equal to \textit{y}" automatically gives us a way to
replace \textit{y} by \textit{x} and vice versa in the process of reasoning,
therefore implementing a discipline of \textit{rewriting}---one of the key
ingredients of the mathematical proof.\footnote{The reader could
have, probably, heard how mathematics sometimes is referred to as a
"science of rewritings".} Later in the chapter, we will see how
rewriting by equality is just a particular case of a general proof
pattern, which allows one to define arbitrary \textit{rewriting rules} by
exploiting Coq's mechanism of \textit{indexed type families}.


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{\textsf{{From}}} \coqdocvar{mathcomp}\coqdoceol
\coqdocnoindent
\coqdockw{Require} \coqdockw{Import} \coqdocvar{ssreflect} \coqdocvar{ssrnat} \coqdocvar{ssrbool} \coqdocvar{eqtype}.\coqdoceol
\coqdocnoindent
\coqdockw{Unset} \coqdockw{Strict} \coqdockw{Implicit}.\coqdoceol
\coqdocnoindent
\coqdockw{Unset} \coqdockw{Printing} \coqdockw{Implicit} \coqdocvar{Defensive}.\coqdoceol
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
\section{Propositional equality in Coq}


\label{sec:propeq}


Let us begin by exploring the definition of the equality predicate ``\coqdocvar{\_}
= \coqdocvar{\_}''.


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Locate} "\_ = \_".\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqdoceol
\coqdocemptyline
\coqdocnoindent
"x = y" := \coqdocinductive{eq} \coqdocvariable{x} \coqdocvariable{y}    : \coqdocvar{type\_scope}

\coqdocemptyline
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Print} \coqdocvar{eq}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdocinductive{eq} (\coqdocvariable{A} : \coqdockw{Type}) (\coqdocvariable{x} : \coqdocvariable{A}) : \coqdocvariable{A} \ensuremath{\rightarrow} \coqdockw{Prop} :=  \coqdocvar{eq\_refl} : \coqdocinductive{eq} \coqdocvariable{x} \coqdocvariable{x}

\coqdocemptyline


\ssrd{eq}


As we can see, the equality is just yet another inductive predicate,
similar to the logical connectives we've seen in
Chapter~\ref{ch:logic}. However, there are differences, which are of
importance. First, equality as a predicate is \textit{parametrized}
\index{datatype parameters} over two arguments: a \coqdockw{Type} \coqdocvariable{A} of an
unspecified universe (so, it can be \coqdockw{Set}, \coqdockw{Prop} or any of the higher
universes) and an element \coqdocvariable{x} of type \coqdocvariable{A}. There is nothing
particularly new here: we have seen parametrized inductive predicates
before, for instance, conjunction and disjunction in
Section~\ref{sec:conjdisj}. The novel part of this definition is
what comes after the colon trailing the parameter list. Unlike all
previously seen logical connectives, the equality predicate has type
\coqdocvariable{A} \ensuremath{\rightarrow} \coqdockw{Prop} in contrast to just \coqdockw{Prop}. In the Coq terminology, it
means that \coqdocinductive{eq} is not just inductively-defined datatype, but is an
\textit{indexed type family}.\index{indexed type families} In this
particular case, it is indexed \index{datatype indices} by elements
of type \coqdocvariable{A}, which appears at the left of the arrow.


\index{parameters|see {datatype parameters}}
\index{indices|see {datatype indices}}
\index{GADT|see {generalized algebraic datatypes}}


\index{generalized algebraic datatypes}It is common to think of
indexed type families in Coq as of \textit{generalized algebraic datatypes}
(GADTs)~\cite{PeytonJones-al:ICFP06,Xi-al:POPL03}, familiar from
\index{Haskell} Haskell, and allowing one to refine the process
pattern matching basing on the type index of the scrutinee. However,
another analogy turns out to be much more useful in the Coq setting:
indexed type families in fact allow one to encode \textit{rewriting
principles}. To understand, what the indexed datatype definition has
to do with rewriting, let us take a close look at the definition of
\coqdocinductive{eq}. The type of its only constructor \coqdocvar{eq\_refl} is a bit misleading,
as it looks like it is applied to two arguments: \coqdocvariable{x} and ... \coqdocvariable{x}. To
disambiguate it, we shall put some parentheses, so, in fact, it should
read~as


\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdocinductive{eq} (\coqdocvariable{A} : \coqdockw{Type}) (\coqdocvariable{x} : \coqdocvariable{A}) : \coqdocvariable{A} \ensuremath{\rightarrow} \coqdockw{Prop} :=  \coqdocvar{eq\_refl} : (\coqdocinductive{eq} \coqdocvariable{x}) \coqdocvariable{x}

\coqdocemptyline


That is, the constructor \coqdocvar{eq\_refl} delivers an element of type (\coqdocinductive{eq} \coqdocvariable{x}),
whose \textit{parameter} is some \coqdocvariable{x} (and \coqdocinductive{eq} is directly applied to it),
and its \textit{index} (which comes second) is constrained to be \coqdocvariable{x} as
well. That is, case-analysing on an instance of \coqdocinductive{eq} \coqdocvariable{x} \coqdocvariable{y} in the
process of the proof construction will inevitably lead the side
condition implying that \coqdocvariable{x} and \coqdocvariable{y} actually correspond to the \textit{same
object}. Coq will take advantage of this fact immediately, by
performing the \textit{unification} \index{unification} and substituting
all occurrences of \coqdocvariable{y} in the subsequent goal with \coqdocvariable{x}.  Let us see
how it works in practice.


\subsection{Case analysis on an equality witness}




To demonstrate the actual proofs on the case analysis by equality, we
will have to perform an awkward twist: define \textit{our own} equality
predicate. 


\ccom{Set Implicit Arguments}


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Set Implicit Arguments}.\coqdoceol
\coqdocnoindent
\coqdockw{Inductive} \coqdocvar{my\_eq} (\coqdocvar{A} : \coqdockw{Type}) (\coqdocvar{x} : \coqdocvar{A}) : \coqdocvar{A} \ensuremath{\rightarrow} \coqdockw{Prop} :=  \coqdocvar{my\_eq\_refl} : \coqdocvar{my\_eq} \coqdocvar{x} \coqdocvar{x}.\coqdoceol
\coqdocnoindent
\coqdockw{Notation} "x === y" := (\coqdocvar{my\_eq} \coqdocvar{x} \coqdocvar{y}) (\coqdoctac{at} \coqdockw{level} 70).\coqdoceol
\coqdocemptyline
\end{coqdoccode}


As we can see, this definition literally repeats the Coq's standard
definition of propositional equality. The reason for the code
duplication is that Ssreflect provides a specific treatment of Coq's
standard equality predicate, so the case-analysis on its instances is
completely superseded by the powerful \coqdoctac{rewrite} tactics, which we will
see in Section~\ref{sec:rewriting} of this chapter. Alas, this
special treatment also leads to a non-standard behaviour of
case-analysis on equality. This is why, for didactical purposes, we
will have to stick with or own home-brewed definition until the end of
this section.


Let us now prove some interesting properties of the freshly-defined
equality. We start with symmetry of === by formulating the
following lemma:\footnote{The Coq's command \texttt{Lemma} is
identical to \texttt{Theorem}.\ccom{Lemma}}


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{my\_eq\_sym} \coqdocvar{A} (\coqdocvar{x} \coqdocvar{y}: \coqdocvar{A}) : \coqdocvar{x} === \coqdocvar{y} \ensuremath{\rightarrow} \coqdocvar{y} === \coqdocvar{x}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}


First, we perform the case analysis on the top assumption of the goal,
\coqdocvariable{x} === \coqdocvariable{y}.


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdoctac{case}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}


\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdocvariable{A} : \coqdockw{Type}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{x} : \coqdocvariable{A}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{y} : \coqdocvariable{A}\coqdoceol
\coqdocindent{1.00em}
============================\coqdoceol
\coqdocindent{1.50em}
\coqdocvariable{x} === \coqdocvariable{x}

\coqdocemptyline


This leads to the goal, being switched from \coqdocvariable{y} === \coqdocvariable{x} to \coqdocvariable{x} === \coqdocvariable{x}, as
all occurrences of \coqdocvariable{y} are now replaced by \coqdocvariable{x}, exactly as advertised.
We can now finish the proof by applying the constructor (\coqdoctac{apply}:
\coqdocvar{my\_refl\_eq}) or simply by \coqdocvar{\texttt{\emph{done}}}, which is powerful enough to figure
out what to apply.


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdocvar{\texttt{\emph{done}}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}


Our next exercise will be to show that the predicate we have just
defined implies Leibniz equality. The proof is accomplished in one
\index{Leibniz equality} line by case-analysing on the equality,
which leads to the automatic replacements of \coqdocvariable{y} by \coqdocvariable{x}.


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{my\_eq\_Leibniz} \coqdocvar{A} (\coqdocvar{x} \coqdocvar{y}: \coqdocvar{A}) (\coqdocvar{P}: \coqdocvar{A} \ensuremath{\rightarrow} \coqdockw{Prop}) : \coqdocvar{x} === \coqdocvar{y} \ensuremath{\rightarrow} \coqdocvar{P} \coqdocvar{x} \ensuremath{\rightarrow} \coqdocvar{P} \coqdocvar{y}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{by} \coqdoctac{case}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}


\subsection{Implementing discrimination}


\label{sec:discr}


Another important application of the equality predicate family and
similar ones \index{discrimination} are \textit{proofs by discrimination},
in which the contradiction is reached (i.e., the falsehood is derived)
out of the fact that two clearly non-equal elements are assumed to be
equal. The next lemma demonstrates the essence of the proof by
discrimination using the \coqdocinductive{my\_eq} predicate.


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{disaster} : 2 === 1 \ensuremath{\rightarrow} \coqdocvar{False}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocnoindent
\coqdoctac{move}\ensuremath{\Rightarrow} \coqdocvar{H}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}


\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdocvar{H} : 2 === 1\coqdoceol
\coqdocindent{1.00em}
============================\coqdoceol
\coqdocindent{1.50em}
\coqdocinductive{False}

\coqdocemptyline


As it is already hinted by the name of the method, the key insight in
the proofs by discrimination is to construct a function that can
distinguish between values of the type with an implicit \textit{definitional
equality},\index{definitional equality} which relates two values if
they have identical structure.\footnote{It is not trivial to
establish computable definitional equality on \emph{any} values, as
the values might be of an infinite nature. For instance, stating the
equality of two functions would require checking their results on all
elements of the common domain, which might be infinite. in this
respect, propositional equality acts like it ``compares the
references'', whereas definitional equality ``compares the structure''
of two elements.} In particular, natural numbers can be compared
against each other by means of direct pattern matching, which is
decidable for them, thanks to the inductive definition. Using this
insight we define a local ``discriminating'' function \coqdocvar{D} using the
Ssreflect's enhanced \coqdoctac{pose} \ssrt{pose} tactic:


 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdoctac{pose} \coqdocvar{D} \coqdocvar{x} := \coqdockw{if} \coqdocvar{x} \coqdockw{\texttt{\emph{is}}} 2 \coqdockw{then} \coqdocvar{False} \coqdockw{else} \coqdocvar{True}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}


\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdocvar{H} : 2 === 1\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{D} := \coqdockw{fun} \coqdocvariable{x} : \coqdocinductive{nat} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.50em}
\coqdockw{match} \coqdocvariable{x} \coqdockw{with}\coqdoceol
\coqdocindent{3.50em}
\ensuremath{|} 0 \ensuremath{\Rightarrow} \coqdocinductive{True}\coqdoceol
\coqdocindent{3.50em}
\ensuremath{|} 1 \ensuremath{\Rightarrow} \coqdocinductive{True}\coqdoceol
\coqdocindent{3.50em}
\ensuremath{|} 2 \ensuremath{\Rightarrow} \coqdocinductive{False}\coqdoceol
\coqdocindent{3.50em}
\ensuremath{|} \coqdocconstructor{S} (\coqdocconstructor{S} (\coqdocconstructor{S} \coqdocvar{\_})) \ensuremath{\Rightarrow} \coqdocinductive{True}\coqdoceol
\coqdocindent{3.50em}
\coqdockw{end} : \coqdocinductive{nat} \ensuremath{\rightarrow} \coqdockw{Prop}\coqdoceol
\coqdocindent{1.00em}
============================\coqdoceol
\coqdocindent{1.50em}
\coqdocinductive{False}

\coqdocemptyline


Now, proving \coqdocvar{D} 1 is \coqdocinductive{True} can be accomplished by simple executing
\coqdocvar{D} with appropriate arguments (recall that \coqdocvar{D} is an
always-terminating function, whose result is a computable value). That
Ssreflect's tactic \coqdocvar{\texttt{\emph{have}}}\ssrt{have} allows to declare the local
fact, which can be then proved in-place by simple computation (which
is performed via \coqdoctac{by} []).


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdocvar{\texttt{\emph{have}}} \coqdocvar{D1}: \coqdocvar{D} 1.\coqdoceol
\coqdocnoindent
\coqdoctac{by} [].\coqdoceol
\coqdocemptyline
\end{coqdoccode}


\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdocvar{H} : 2 === 1\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{D} := ...\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{D1} : \coqdocvar{D} 1\coqdoceol
\coqdocindent{1.00em}
============================\coqdoceol
\coqdocindent{1.50em}
\coqdocinductive{False}

\coqdocemptyline


Next we ``push'' \coqdocvar{D1} and \coqdocvar{H} back to the goal (using the : tactical),
and case-analyse on the top assumption \coqdocvar{H}. Notice that the semantics
of : \ssrtl{:} is such that it first performs a series of
``pushings'' and then runs the tactic on the left of itself (i.e.,
\coqdoctac{case}).


 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdoctac{case}: \coqdocvar{H} \coqdocvar{D1}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}


\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdocvar{D} := ...\coqdoceol
\coqdocindent{1.00em}
============================\coqdoceol
\coqdocindent{1.50em}
\coqdocvar{D} 2 \ensuremath{\rightarrow} \coqdocinductive{False}

\coqdocemptyline


Now, we got what we have needed: the proof of the falsehood! Thanks to
the equality-provided substitution, \coqdocvar{D} 1 turned into \coqdocvar{D} 2, and the
only thing that remains now is to \textit{evaluate} it.


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdoctac{move}=>/=.\coqdoceol
\coqdocemptyline
\end{coqdoccode}


The tactical \ssrtl{/=}/=, coming after \ensuremath{\Rightarrow} runs all possible
simplifications on the result obtained by the tactics, preceding \ensuremath{\Rightarrow},
finishing the proof.


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdocvar{\texttt{\emph{done}}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}


Let us provide a bit more explanation how did it happen that we
managed to derive the falsehood in the process of the proof. The
discrimination function \coqdocvar{D} is a function from \coqdocinductive{nat} to \coqdockw{Prop}, and,
indeed, it can return \coqdocinductive{True} and \coqdocinductive{False}, so it contains no
contradictions by itself. We also managed to prove easily a trivial
proposition \coqdocvar{D} 1, which is just \coqdocinductive{True}, so it's derivable. The
genuine twist happened when we managed to turn the assumption \coqdocvar{D} 1
(which was \coqdocinductive{True}) to \coqdocvar{D} 2 (which is \coqdocinductive{False}). This was only possible
because of the assumed equality 2 === 1, which contained the
``falsehood'' from the very beginning and forced Coq to substitute the
occurrence of 1 in the goal by 2, so the discrimination function
in the assumption finished the job.


\begin{exercise}
Let us change the statement of a previous lemma for a little bit:


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{disaster2} : 1 === 2 \ensuremath{\rightarrow} \coqdocvar{False}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\noindent
Now, try to prove it using the same scheme. What goes wrong and how to
fix it?


\end{exercise}


\begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}


\subsection{Reasoning with Coq's standard equality}




Now we know what drives the reasoning by equality and discrimination,
so let us forget about the home-brewed predicate \coqdocinductive{my\_eq} and use the
standard equality instead. Happily, the discrimination pattern we used
to implement ``by hand'' now is handled by Coq/Ssreflect automatically,
so the trivially false equalities deliver the proofs right away by
simply typing \coqdocvar{\texttt{\emph{done}}}. 


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{disaster3}: 2 = 1 \ensuremath{\rightarrow} \coqdocvar{False}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdocvar{\texttt{\emph{done}}}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}


Moreover, the case-analysing on the standard equality now comes in the
form of the powerful \coqdoctac{rewrite} tactics, which takes the reasoning to
the whole new level and is a subject of the next section.


\section{Proofs by rewriting \label{sec:rewriting}}




The vast majority of the steps when constructing real-life proofs in
Coq are \textit{rewriting} steps. The general flow of the interactive proof
(considered in more detail in Chapter~\ref{ch:ssrstyle}) is
typically targeted on formulating and proving small auxiliary
hypotheses about equalities in the forward-style reasoning and then
exploiting the derived equalities by means of rewriting in the goal
and, occasionally, other assumptions in the context. All rewriting
machinery is handled by Ssreflect's enhanced \coqdoctac{rewrite}\ssrt{rewrite}
tactics, and in this section we focus on its particular uses.


\subsection{Unfolding definitions and in-place rewritings}


\label{sec:in-place}


One of the common uses of the \coqdoctac{rewrite} tactic is to fold/unfold
transparent definitions. In general, Coq is capable to perform the
unfoldings itself, whenever it's required. Nevertheless, manual
unfolding of a definition might help to understand the details of the
implementation, as demonstrated by the following example.


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{double} \{\coqdocvar{A}\} (\coqdocvar{f}: \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{A}) (\coqdocvar{x}: \coqdocvar{A}) := \coqdocvar{f} (\coqdocvar{f} \coqdocvar{x}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{nat\_iter} (\coqdocvar{n} : \coqdocvar{nat}) \{\coqdocvar{A}\} (\coqdocvar{f} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{A}) (\coqdocvar{x} : \coqdocvar{A}) : \coqdocvar{A} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{if} \coqdocvar{n} \coqdockw{\texttt{\emph{is}}} \coqdocvar{S} \coqdocvar{n'} \coqdockw{then} \coqdocvar{f} (\coqdocvar{nat\_iter} \coqdocvar{n'} \coqdocvar{f} \coqdocvar{x}) \coqdockw{else} \coqdocvar{x}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{double2} \coqdocvar{A} (\coqdocvar{x}: \coqdocvar{A}) \coqdocvar{f} \coqdocvar{t}: \coqdoceol
\coqdocindent{1.00em}
\coqdocvar{t} = \coqdocvar{double} \coqdocvar{f} \coqdocvar{x} \ensuremath{\rightarrow} \coqdocvar{double} \coqdocvar{f} \coqdocvar{t} = \coqdocvar{nat\_iter} 4 \coqdocvar{f} \coqdocvar{x}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}


The first thing to do in this proof is to get rid of the auxiliary
variable \coqdocvariable{t}, as it does not occur in any of the assumptions, but just
in the subsequent goal. This can be done using the following sequence
of tactics that first moves the equality assumption to the top and
then rewrites by it in the goal.


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdoctac{move}\ensuremath{\Rightarrow}\coqdocvar{Et}; \coqdoctac{rewrite} \coqdocvar{Et}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}


\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdocvariable{A} : \coqdockw{Type}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{x} : \coqdocvariable{A}\coqdoceol
\coqdocindent{1.00em}
\coqdocdefinition{f} : \coqdocvariable{A} \ensuremath{\rightarrow} \coqdocvariable{A}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{t} : \coqdocvariable{A}\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Et} : \coqdocvariable{t} = \coqdocdefinition{double} \coqdocdefinition{f} \coqdocvariable{x}\coqdoceol
\coqdocindent{1.00em}
============================\coqdoceol
\coqdocindent{1.50em}
\coqdocdefinition{double} \coqdocdefinition{f} (\coqdocdefinition{double} \coqdocdefinition{f} \coqdocvariable{x}) = \coqdocdefinition{nat\_iter} 4 \coqdocdefinition{f} \coqdocvariable{x}

\coqdocemptyline


Even though the remaining goal is simple enough to be completed by
\coqdocvar{\texttt{\emph{done}}}, let us unfold both definition to make sure that the two terms
are indeed equal structurally. Such unfoldings can be \textit{chained}, just
as any other rewritings.


 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdoctac{rewrite} /\coqdocvar{double} /\coqdocvar{nat\_iter}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdocvariable{x} : \coqdocvariable{A}\coqdoceol
\coqdocindent{1.00em}
\coqdocdefinition{f} : \coqdocvariable{A} \ensuremath{\rightarrow} \coqdocvariable{A}\coqdoceol
\coqdocindent{1.00em}
============================\coqdoceol
\coqdocindent{1.50em}
\coqdocdefinition{f} (\coqdocdefinition{f} (\coqdocdefinition{f} (\coqdocdefinition{f} \coqdocvariable{x}))) = \coqdocdefinition{f} (\coqdocdefinition{f} (\coqdocdefinition{f} (\coqdocdefinition{f} \coqdocvariable{x})))

\coqdocemptyline


An alternative way to prove the same statement would be to use the
\texttt{->} \ssrtl{->} tactical, which is usually combined with
\coqdoctac{move} or \coqdoctac{case}, but instead of moving the assumption to the top, it
makes sure that the assumption is an equality and rewrites by it.


 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Restart}.\coqdoceol
\coqdocnoindent
\coqdoctac{by} \coqdoctac{move}=>->; \coqdoctac{rewrite} /\coqdocvar{double}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}


Notice that the tactical has a companion one \texttt{<-}\ssrtl{<-},
which performs the rewriting by an equality assumption from right to
left, in contrast to \texttt{->}, which rewrites left to right.


\textit{Folding}, the reverse operation to unfolding, is done by using \coqdoctac{rewrite}
-/...  instead of \coqdoctac{rewrite} /...\footnote{As the reader will notice
soon, it is a general pattern with Ssreflect's rewriting to prefix a
\texttt{rewrite} argument with \texttt{-}, if the \emph{reverse}
rewriting operation should be performed.}


\subsection{Proofs by congruence and rewritings by lemmas}




\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{f} \coqdocvar{x} \coqdocvar{y} :=  \coqdocvar{x} + \coqdocvar{y}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Goal} \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{y}, \coqdocvar{x} + \coqdocvar{y} + (\coqdocvar{y} + \coqdocvar{x}) = \coqdocvar{f} \coqdocvar{y} \coqdocvar{x} + \coqdocvar{f} \coqdocvar{y} \coqdocvar{x}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocnoindent
\coqdoctac{move}\ensuremath{\Rightarrow} \coqdocvar{x} \coqdocvar{y}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}


First, let us unfold only all occurrences of \coqdocdefinition{f} in the goal.


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdoctac{rewrite} /\coqdocvar{f}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}


\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdocvariable{x} : \coqdocinductive{nat}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{y} : \coqdocinductive{nat}\coqdoceol
\coqdocindent{1.00em}
============================\coqdoceol
\coqdocindent{1.50em}
\coqdocvariable{x} + \coqdocvariable{y} + (\coqdocvariable{y} + \coqdocvariable{x}) = \coqdocvariable{y} + \coqdocvariable{x} + (\coqdocvariable{y} + \coqdocvariable{x})

\coqdocemptyline


We can now reduce the goal by appealing to Ssreflect's \coqdocvar{\texttt{\emph{congr}}}
tactics, which takes advantage of the fact that equality implies
Leibniz' equality, in particular, with respect to the addition taken
as a function, so the external addition of equal elements can be
``stripped off''.


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdocvar{\texttt{\emph{congr}}} (\coqdocvar{\_} + \coqdocvar{\_}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}


\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdocvariable{x} : \coqdocinductive{nat}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{y} : \coqdocinductive{nat}\coqdoceol
\coqdocindent{1.00em}
============================\coqdoceol
\coqdocindent{1.50em}
\coqdocvariable{x} + \coqdocvariable{y} = \coqdocvariable{y} + \coqdocvariable{x}

\coqdocemptyline


Now, the only thing left to prove is that the addition is commutative,
so at this point we will just make use of Ssreflect's \coqdoclibrary{ssrnat} library
lemma for integer addition.


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} \coqdocvar{addnC}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoclemma{addnC}\coqdoceol
\coqdocindent{2.50em}
: \coqdocvar{ssrfun.commutative} \coqdocvar{addn}

\coqdocemptyline


At this point such signature might seem a bit cryptic, but worry not:
this is just a way to express in a generic way that the addition over
natural numbers is commutative, which can be witnessed by checking the
definition of \coqdocvar{ssrfun.commutative} predicate:


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Print} \coqdocvar{ssrfun.commutative}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}


\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdocvar{ssrfun.commutative} = \coqdoceol
\coqdocindent{1.00em}
\coqdockw{fun} (\coqdocconstructor{S} \coqdocvar{T} : \coqdockw{Type}) (\coqdocvar{op} : \coqdocconstructor{S} \ensuremath{\rightarrow} \coqdocconstructor{S} \ensuremath{\rightarrow} \coqdocvar{T}) \ensuremath{\Rightarrow} \coqdockw{\ensuremath{\forall}} \coqdocvariable{x} \coqdocvariable{y} : \coqdocconstructor{S}, \coqdocvar{op} \coqdocvariable{x} \coqdocvariable{y} = \coqdocvar{op} \coqdocvariable{y} \coqdocvariable{x}\coqdoceol
\coqdocindent{3.50em}
: \coqdockw{\ensuremath{\forall}} \coqdocconstructor{S} \coqdocvar{T} : \coqdockw{Type}, (\coqdocconstructor{S} \ensuremath{\rightarrow} \coqdocconstructor{S} \ensuremath{\rightarrow} \coqdocvar{T}) \ensuremath{\rightarrow} \coqdockw{Prop}

\coqdocemptyline


As we can see, the definition of the \coqdocdefinition{commutative} predicate ensures
the equality of the operation's result with its arguments, permuted,
hence \coqdocvar{op} \coqdocvariable{x} \coqdocvariable{y} = \coqdocvar{op} \coqdocvariable{y} \coqdocvariable{x}. The type of the lemma \coqdoclemma{addnC} therefore
refines \coqdocvar{op} to be ``\coqdocvar{\_} + \coqdocvar{\_}'', so, after specializing the definition
appropriately, the type of \coqdoclemma{addnC} should be read as:


\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoclemma{addnC}\coqdoceol
\coqdocindent{2.50em}
: \coqdockw{\ensuremath{\forall}} \coqdocvariable{n} \coqdocvariable{m}: \coqdocinductive{nat}, \coqdocvariable{n} + \coqdocvariable{m} = \coqdocvariable{m} + \coqdocvariable{n}

\coqdocemptyline


Now, we can take advantage of this equality and rewrite by it a part
of the goal. Notice that Coq will figure out how the
universally-quantified variables should be instantiated (i.e., with
\coqdocvariable{y} and \coqdocvariable{x}, respectively):


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdoctac{by} \coqdoctac{rewrite} [\coqdocvar{y} + \coqdocvar{\_}]\coqdocvar{addnC}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}


The \textit{r-pattern} \index{r-pattern} (regex pattern) [\coqdocvariable{y} + \coqdocvar{\_}],
preceding the lemma to be used for rewriting, specifies, which
subexpression of the goal should be a subject of rewriting. When
non-ambiguous, some parts of the expressions can be replaced by
wildcard \index{wildcards} underscores \coqdocvar{\_}. In this particular case,
it does not matter that much, since any single rewriting by
commutativity in any of the sums, on the left or on the right, would
make the proof to go through. However, in a more sophisticated goal it
makes sense to specify explicitly, what should be rewritten:


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Goal} \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{y} \coqdocvar{z}, (\coqdocvar{x} + (\coqdocvar{y} + \coqdocvar{z})) = (\coqdocvar{z} + \coqdocvar{y} + \coqdocvar{x}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocnoindent
\coqdoctac{by} \coqdoctac{move}\ensuremath{\Rightarrow}\coqdocvar{x} \coqdocvar{y} \coqdocvar{z}; \coqdoctac{rewrite} [\coqdocvar{y} + \coqdocvar{\_}]\coqdocvar{addnC}; \coqdoctac{rewrite} [\coqdocvar{z} + \coqdocvar{\_} + \coqdocvar{\_}]\coqdocvar{addnC}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}


Proofs of ``obvious'' equalities that hold modulo, e.g., commutativity
and subjectivity, usually require several rewriting to be established,
which might be tedious.  There are ways to automate such proofs by
means of overloaded lemmas via \textit{canonical structures}. These
techniques, hinted briefly in Chapter~\ref{ch:depstruct}, are mostly
outside of the scope of this course, so we address the reader to a
number of papers, presenting the state of the art in this
direction~\cite{Gontier-al:ICFP11,Mahboubi-Tassi:ITP13}.


\subsection{Naming in subgoals and optional rewritings}


\label{sec:naming-subgoals}


When working with multiple cases, it is possible to ``chain'' the
execution of several tactics. Then, in the case of a script \coqdocvar{tac1};
\coqdocvar{tac2}, if the goal is replaced by several after applying \coqdocvar{tac1}, then
\coqdocvar{tac2} will be applied to \textit{all} subgoals, generated by \coqdocvar{tac1}. For
example, let us consider a proof of the following lemma from the
standard \coqdoclibrary{ssrnat} \ssrm{ssrnat} module:


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{addnCA}: \coqdockw{\ensuremath{\forall}} \coqdocvar{m} \coqdocvar{n} \coqdocvar{p}, \coqdocvar{m} + (\coqdocvar{n} + \coqdocvar{p}) = \coqdocvar{n} + (\coqdocvar{m} + \coqdocvar{p}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocnoindent
\coqdoctac{move}\ensuremath{\Rightarrow}\coqdocvar{m} \coqdocvar{n}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}


\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdocvariable{m} : \coqdocinductive{nat}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} : \coqdocinductive{nat}\coqdoceol
\coqdocindent{1.00em}
============================\coqdoceol
\coqdocindent{1.50em}
\coqdockw{\ensuremath{\forall}} \coqdocvariable{p} : \coqdocinductive{nat}, \coqdocvariable{m} + (\coqdocvariable{n} + \coqdocvariable{p}) = \coqdocvariable{n} + (\coqdocvariable{m} + \coqdocvariable{p})

\coqdocemptyline


The proof will proceed by induction on \coqdocvariable{m}. We have already seen the
use of the \coqdoctac{case} tactics, which just performs the case
analysis. Another Ssreflect tactic \coqdoctac{elim} \ssrt{elim} generalizes
\coqdoctac{case} by applying the default induction principle (\coqdocvar{nat\_ind} in this
case) with the respect to the remaining goal (that is, the predicate
[\coqdockw{\ensuremath{\forall}} \coqdocvariable{p} : \coqdocinductive{nat}, \coqdocvariable{m} + (\coqdocvariable{n} + \coqdocvariable{p}) = \coqdocvariable{n} + (\coqdocvariable{m} + \coqdocvariable{p})]) is to be proven by
induction.  The following sequence of tactics proceeds by induction on
\coqdocvariable{m} with the default induction principle. It also names some of the
generated assumptions. 


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdoctac{elim}: \coqdocvar{m}=>[ \ensuremath{|} \coqdocvar{m} \coqdocvar{Hm} ] \coqdocvar{p}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}


In particular, the following steps are performed:



\begin{itemize}
\item  \coqdocvariable{m} is pushed as a top assumption of the goal;

\item  \coqdoctac{elim} is run, which leads to generation of the two goals;



\begin{itemize}
\item  The first goal is of the shape
\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{\ensuremath{\forall}} \coqdocvariable{p} : \coqdocinductive{nat}, 0 + (\coqdocvariable{n} + \coqdocvariable{p}) = \coqdocvariable{n} + (0 + \coqdocvariable{p})

\coqdocemptyline



\item  The second goal has the shape
\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{\ensuremath{\forall}} \coqdocvar{n0} : \coqdocinductive{nat},\coqdoceol
\coqdocindent{0.50em}
(\coqdockw{\ensuremath{\forall}} \coqdocvariable{p} : \coqdocinductive{nat}, \coqdocvar{n0} + (\coqdocvariable{n} + \coqdocvariable{p}) = \coqdocvariable{n} + (\coqdocvar{n0} + \coqdocvariable{p})) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{0.50em}
\coqdockw{\ensuremath{\forall}} \coqdocvariable{p} : \coqdocinductive{nat}, \coqdocvar{n0}.+1 + (\coqdocvariable{n} + \coqdocvariable{p}) = \coqdocvariable{n} + (\coqdocvar{n0}.+1 + \coqdocvariable{p})

\coqdocemptyline



\end{itemize}

\item  The subsequent structured naming \ensuremath{\Rightarrow} [ \ensuremath{|}\coqdocvariable{m} \coqdocvar{Hm} ] \coqdocvariable{p} names zero
  assumptions in the first goal and the two top assumptions, \coqdocvariable{m} and
  \coqdocvar{Hm}, in the second goal. It then next names the assumption \coqdocvariable{p} in
  \textit{both} goals and moves it to the top.

\end{itemize}


The first goal can now be proved by multiple rewritings via the lemma
\coqdoclemma{add0n}, stating that 0 is the left unit with respect to the
addition:


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdoctac{by} \coqdoctac{rewrite} !\coqdocvar{add0n}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}


The second goal can be proved by a series of rewritings using the fact
about the (\coqdocvar{\_} + 1) function:


 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdoctac{by} \coqdoctac{rewrite} !\coqdocvar{addSnnS} -\coqdocvar{addnS}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\noindent
Notice that the conclusion of the \coqdoclemma{addnS} lemma is rewritten right-to-left.


The whole proof could be, however, accomplished in one line using the
\textit{optional} rewritings. The intuitions is to \textit{chain} the rewritings
in the goals, generated by \coqdoctac{elim} in a way that the unsuccessful
rewriting would not fail the whole proof construction, as they are
irrelevant for some goals anyway. This is how it can be done:


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Restart}.\coqdoceol
\coqdocnoindent
\coqdoctac{by} \coqdoctac{move}\ensuremath{\Rightarrow}\coqdocvar{m} \coqdocvar{n}; \coqdoctac{elim}: \coqdocvar{m}=>[ \ensuremath{|} \coqdocvar{m} \coqdocvar{Hm} ] \coqdocvar{p}; \coqdoctac{rewrite} ?\coqdocvar{add0n} ?\coqdocvar{addSnnS} -?\coqdocvar{addnS}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}


Notice that the optional rewritings (e.g., ?\coqdoclemma{addSnnS}) are
performed as many times as they can be.


\subsection{Selective occurrence rewritings}




Sometimes, instead of providing an r-pattern to specialize the
rewriting, it is more convenient to specify, which particular
syntactic occurrences\index{occurrence switch} in the goal term
should be rewritten. This is demonstrated by the following alternative
proof of commutativity of addition from the lemma \coqdoclemma{addnCA}, which we
have proved before:


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{addnC}: \coqdockw{\ensuremath{\forall}} \coqdocvar{m} \coqdocvar{n}, \coqdocvar{m} + \coqdocvar{n} = \coqdocvar{n} + \coqdocvar{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocnoindent
\coqdoctac{by} \coqdoctac{move}\ensuremath{\Rightarrow} \coqdocvar{m} \coqdocvar{n}; \coqdoctac{rewrite} -\{1\}[\coqdocvar{n}]\coqdocvar{addn0} \coqdocvar{addnCA} \coqdocvar{addn0}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}


The first rewriting with \coqdoclemma{addn0} ``adds'' 0 to the first occurrence of
\coqdoclemma{addn0}, so the left-hand side of the equality becomes \coqdocvariable{m} + (\coqdocvariable{n} +
0). The next rewriting employs the lemma \coqdoclemma{addnCA}, so we get \coqdocvariable{n} + (\coqdocvariable{m}
+ 0) = \coqdocvariable{n} + \coqdocvariable{m} as the goal, and the last one ``removes'' zero, so the
result trivially follows.


We conclude this section by noticing that the same rewriting machinery
is applicable not only to the goal, but also to hypotheses in the
assumption context using the \coqdoctac{rewrite} \coqdocvar{H1} \coqdoctac{in} \coqdocvar{H2} syntax (where \coqdocvar{H1} is
the rewriting hypothesis and \coqdocvar{H2} is a hypothesis, where the rewriting
should happen). There are many more tricks that can be done with
rewritings, and we address the reader to Chapter~7 of Ssreflect
manual~\cite{Gontier-al:TR}.




\section{Indexed datatype families as rewriting rules}


\label{sec:indexed}


In Section~\ref{sec:propeq} of this chapter we have already seen how
defining indexed datatype families \index{indexed type families}
makes it possible for Coq to provide a convenient rewriting machinery,
which is implicitly invoked by case analysis on such families' refined
types, thanks to sophisticated Coq's unification procedure.


Although so far this approach has been demonstrated by only one
indexed type family example---propositional equality, defined by means
of the \coqdocinductive{eq} family, in this section, concluding the chapter, we will
show how to define other client-specific rewriting rules. Let us start
from a motivating example in the form of an ``obvious'' lemma.


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{huh} \coqdocvar{n} \coqdocvar{m}: (\coqdocvar{m} \ensuremath{\le} \coqdocvar{n}) \ensuremath{\land} (\coqdocvar{m} > \coqdocvar{n}) \ensuremath{\rightarrow} \coqdocvar{False}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}


From now on, we will be consistently including yet another couple of
Ssreflect modules, \coqdoclibrary{ssrbool} and \coqdoclibrary{eqtype},
\ssrm{ssrbool}\ssrm{eqtype} into our development. The need for them
is due to the smooth combination of reasoning with \coqdockw{Prop}ositions and
\coqdocinductive{bool}eans, which is a subject of the next chapter. Even though in
Ssreflect's library, relations on natural numbers, such as \ensuremath{\le} and
>, are defined as \textit{boolean} functions, so far we recommend to the
reader to think of them as of predicates defined in \coqdockw{Prop} and,
therefore, valid arguments to the \ensuremath{\land} connective.


Although the statement is somewhat obvious, in the setting of Coq's
inductive definition of natural numbers it should be no big surprise
that it is proved by induction. We present the proof here, leaving the
details aside, so the reader could figure them out on her own, as a
simple exercise.\ssrt{elim}\ssrt{suff:}\ssrtl{//}


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocnoindent
\coqdocvar{\texttt{\emph{suff}}} \coqdocvar{X}: \coqdocvar{m} \ensuremath{\le} \coqdocvar{n} \ensuremath{\rightarrow} \~{}(\coqdocvar{m} > \coqdocvar{n}) \coqdoctac{by} \coqdoctac{case}=>/\coqdocvar{X}.\coqdoceol
\coqdocnoindent
\coqdoctac{by} \coqdoctac{elim}: \coqdocvar{m} \coqdocvar{n} \ensuremath{\Rightarrow} [ \ensuremath{|} \coqdocvar{m} \coqdocvar{IHm} ] [ \ensuremath{|} \coqdocvar{n}] //; \coqdoctac{exact}: \coqdocvar{IHm} \coqdocvar{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}


Even this small example should make it feel like ``something is not
right'', as a trivial mutual exclusion property required some inductive
reasoning. A bigger problem is, however, that this mutual exclusion
does not directly provide us with a ``case-analysis'' principle, which a
human prover would naturally employ when reasoning about, for
instance, a natural definition of the ``maximum'' function


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{maxn} \coqdocvar{m} \coqdocvar{n} := \coqdockw{if} \coqdocvar{m} < \coqdocvar{n} \coqdockw{then} \coqdocvar{n} \coqdockw{else} \coqdocvar{m}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}


and the following fact about its correctness


\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdoclemma{max\_is\_max} \coqdocvariable{m} \coqdocvariable{n}: \coqdocvariable{n} \ensuremath{\le} \coqdocdefinition{maxn} \coqdocvariable{m} \coqdocvariable{n} \ensuremath{\land} \coqdocvariable{m} \ensuremath{\le} \coqdocdefinition{maxn} \coqdocvariable{m} \coqdocvariable{n}.

\coqdocemptyline


The stated lemma \coqdoclemma{max\_is\_max} can be, indeed, proved by induction on
\coqdocvariable{m} and \coqdocvariable{n}, which is a rather tedious exercise, so we will not be
following this path.


\subsection{Encoding custom rewriting rules}


\label{sec:enccustom}


In the rest of this section, we will leverage the intuition behind
indexed type families considered as \textit{rewriting rules},
\index{rewriting rules} and will try to encode a ``truth table''
\index{truth table} with two disjoint variants of relation between
\coqdocvariable{n} and \coqdocvariable{m}, namely, \coqdocvariable{m} \ensuremath{\le} \coqdocvariable{n} and \coqdocvariable{n} < \coqdocvariable{m}. The table itself is encoded
by the following inductive definition:


\ssrd{leq\_xor\_gtn}


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdocvar{leq\_xor\_gtn} \coqdocvar{m} \coqdocvar{n} : \coqdocvar{bool} \ensuremath{\rightarrow} \coqdocvar{bool} \ensuremath{\rightarrow} \coqdockw{Set} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{LeqNotGtn} \coqdockw{\texttt{\emph{of}}} \coqdocvar{m} \ensuremath{\le} \coqdocvar{n} : \coqdocvar{leq\_xor\_gtn} \coqdocvar{m} \coqdocvar{n} \coqdocvar{true} \coqdocvar{false}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{GtnNotLeq} \coqdockw{\texttt{\emph{of}}} \coqdocvar{n} < \coqdocvar{m}  : \coqdocvar{leq\_xor\_gtn} \coqdocvar{m} \coqdocvar{n} \coqdocvar{false} \coqdocvar{true}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}


However, this is not yet enough to enjoy the custom rewriting and case
analysis on these two variant. At this moment, the datatype family
\coqdocinductive{leq\_xor\_gtn}, whose constructors' indices encode a truth table's
``rows'', specifies two substitutions in the case when \coqdocvariable{m} \ensuremath{\le} \coqdocvariable{n} and \coqdocvariable{n} <
\coqdocvariable{m}, respectively and diagrammatically looks as follows:


\begin{verbatim}
         |   C1  |   C2
-------------------------
m <= n   | true  | false
-------------------------
n < m    | false | true
\end{verbatim}


The boolean values in the cells specify what the values of
\texttt{C1} and \texttt{C2} will be substituted \textit{with} in each of
the two cases. However, the table does not capture, what to substitute
them \textit{for}.  Therefore, our next task is to provide suitable variants
for \texttt{C1} and \texttt{C2}, so the table would describe a
real situation and capture exactly the ``case analysis'' intuition. This
values of the columns are captured by the following lemma, which,
informally speaking, states that the table with this particular values
of \texttt{C1} and \texttt{C2} ``makes sense''.


\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdoclemma{leqP} \coqdocvariable{m} \coqdocvariable{n} : \coqdocinductive{leq\_xor\_gtn} \coqdocvariable{m} \coqdocvariable{n} (\coqdocvariable{m} \ensuremath{\le} \coqdocvariable{n}) (\coqdocvariable{n} < \coqdocvariable{m}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocnoindent
\coqdoctac{rewrite} \coqdoclemma{ltnNge}.\coqdoceol
\coqdocnoindent
\coqdoctac{by} \coqdoctac{case} \coqdocvar{le\_mn}: (\coqdocvariable{m} \ensuremath{\le} \coqdocvariable{n}); \coqdoctac{constructor}=>//; \coqdoctac{rewrite} \coqdoclemma{ltnNge} \coqdocvar{le\_mn}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.

\coqdocemptyline


Moreover, the lemma \coqdoclemma{leqP}, which we have just proved, delivers the
necessary instance of the ``truth'' table, which we can now case-analyse
against.\footnote{In theory, a different lemma could be proven for
the same table but for different values of indices, which would give
us a \textit{different} rewriting principle. However, the datatype family
\coqdocinductive{leq\_xor\_gtn}, as it's currently specified, is too ``tight'' to admit
other instances than the one provided by the lemma \coqdoclemma{leqP}, thanks to
the explicit constructors' arguments: \coqdocvariable{m} \ensuremath{\le} \coqdocvariable{n} and \coqdocvariable{n} < \coqdocvariable{m}.}


\subsection{Using custom rewriting rules}




Let us see now, how some proofs might be changed to the good:


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{huh'} \coqdocvar{n} \coqdocvar{m}: (\coqdocvar{m} \ensuremath{\le} \coqdocvar{n}) \ensuremath{\land} (\coqdocvar{m} > \coqdocvar{n}) \ensuremath{\rightarrow} \coqdocvar{False}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}


Let us first ``switch'' from the propositional conjunction \ensuremath{\land} to the
boolean one \&\& using the \textit{view} mechanism by using the \coqdoctac{move}
tactics the trailing tactical \texttt{/}\ssrtl{/}\index{views}. This
trick might look a bit unfair at the moment, but it will be soon
explained in Section~\ref{sec:views} of Chapter~\ref{ch:boolrefl}.


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdoctac{move}/\coqdocvar{andP}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}


\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdocvariable{n} : \coqdocinductive{nat}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{m} : \coqdocinductive{nat}\coqdoceol
\coqdocindent{1.00em}
============================\coqdoceol
\coqdocindent{1.50em}
\coqdocvariable{m} \ensuremath{\le} \coqdocvariable{n} < \coqdocvariable{m} \ensuremath{\rightarrow} \coqdocinductive{False}

\coqdocemptyline


The top assumption \coqdocvariable{m} \ensuremath{\le} \coqdocvariable{n} < \coqdocvariable{m} of the goal is just a syntactic sugar
for (\coqdocvariable{m} \ensuremath{\le} \coqdocvariable{n}) \&\& (\coqdocvariable{n} < \coqdocvariable{m}). 
It is time now to make use of our rewriting rule/truth table,
constructed by means of \coqdoclemma{leqP}.


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdoctac{case}:\coqdocvar{leqP}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}


\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdocvariable{n} : \coqdocinductive{nat}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{m} : \coqdocinductive{nat}\coqdoceol
\coqdocindent{1.00em}
============================\coqdoceol
\coqdocindent{1.50em}
\coqdocvariable{m} \ensuremath{\le} \coqdocvariable{n} \ensuremath{\rightarrow} \coqdocconstructor{true} \&\& \coqdocconstructor{false} \ensuremath{\rightarrow} \coqdocinductive{False}\coqdoceol
\coqdocnoindent
\coqdoceol
\coqdocnoindent
\coqdockw{subgoal} 2 (\coqdocvar{ID} 638) \coqdockw{\texttt{\emph{is}}}:\coqdoceol
\coqdocindent{0.50em}
\coqdocvariable{n} < \coqdocvariable{m} \ensuremath{\rightarrow} \coqdocconstructor{false} \&\& \coqdocconstructor{true} \ensuremath{\rightarrow} \coqdocinductive{False}

\coqdocemptyline


We would recommend to try stepping this line several times, back and
forth to see, what is happening. Two goals were generated, so let us
focus on the first one, as the second one will proceed by
analogy. Case-analysing on the statement of the lemma \coqdoclemma{leqP} resulted
in two different ``options'', as one would expect from the shape of the
table. The first, case, \coqdocvariable{m} \ensuremath{\le} \coqdocvariable{n}, resulted in generating the
assumption \coqdocvariable{m} \ensuremath{\le} \coqdocvariable{n}, as it is an argument of the corresponding
constructor. What is more important, \textit{all} occurrences of the columns'
values were replaced in the goal by the corresponding boolean values,
just as it was encoded in the table! The similar thing happened with
the second goal, which encoded the alternative case, i.e., \coqdocvariable{n} < \coqdocvariable{m}.


Now, considering a boolean value \coqdocconstructor{true} \&\& \coqdocconstructor{false} in a goal simply as a
proposition (\coqdocconstructor{true} \&\& \coqdocconstructor{false}) = \coqdocconstructor{true}, the proof is trivial by
simplification of the boolean conjunction.


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdocvar{\texttt{\emph{done}}}.\coqdoceol
\coqdocnoindent
\coqdocvar{\texttt{\emph{done}}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}


The proof of \coqdoclemma{huh'} is now indeed significantly shorter than the proof
of its predecessor, \coqdoclemma{huh}. However, it might look like the definition
of the rewriting rule \coqdocinductive{leq\_xor\_gtn} and its accompanying lemma \coqdoclemma{leqP}
is quite narrowly-scoped, and it is not clear how useful it might be
for other proofs.


To demonstrate the custom rewriting rules defined by means of indexed
datatype families in their shine, let us get back to the definition
of \coqdocdefinition{maxn} and the lemma about it:


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{max\_is\_max} \coqdocvar{m} \coqdocvar{n}: \coqdocvar{n} \ensuremath{\le} \coqdocvar{maxn} \coqdocvar{m} \coqdocvar{n} \ensuremath{\land} \coqdocvar{m} \ensuremath{\le} \coqdocvar{maxn} \coqdocvar{m} \coqdocvar{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\end{coqdoccode}


The proof begins by unfolding the definition of \coqdocdefinition{maxn}.


\begin{coqdoccode}
\coqdocnoindent
\coqdoctac{rewrite} /\coqdocvar{maxn}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}


\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdocvariable{m} : \coqdocinductive{nat}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} : \coqdocinductive{nat}\coqdoceol
\coqdocindent{1.00em}
============================\coqdoceol
\coqdocindent{1.50em}
\coqdocvariable{n} \ensuremath{\le} (\coqdockw{if} \coqdocvariable{m} < \coqdocvariable{n} \coqdockw{then} \coqdocvariable{n} \coqdockw{else} \coqdocvariable{m}) \ensuremath{\land} \coqdocvariable{m} \ensuremath{\le} (\coqdockw{if} \coqdocvariable{m} < \coqdocvariable{n} \coqdockw{then} \coqdocvariable{n} \coqdockw{else} \coqdocvariable{m})

\coqdocemptyline


We are now in the position to unleash our rewriting rule, which,
together with simplifications by means of the // tactical
\ssrtl{//} does most of the job.


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdoctac{case}: \coqdocvar{leqP}=>//.\coqdoceol
\coqdocemptyline
\end{coqdoccode}


\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdocvariable{m} : \coqdocinductive{nat}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} : \coqdocinductive{nat}\coqdoceol
\coqdocindent{1.00em}
============================\coqdoceol
\coqdocindent{1.50em}
\coqdocvariable{m} < \coqdocvariable{n} \ensuremath{\rightarrow} \coqdocvariable{n} \ensuremath{\le} \coqdocvariable{n} \ensuremath{\land} \coqdocvariable{m} \ensuremath{\le} \coqdocvariable{n}

\coqdocemptyline


The rest of the proof employs rewriting by some trivial lemmas from
\coqdoclibrary{ssrnat}, \ssrm{ssrnat} but conceptually is very easy.


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdoctac{move}\ensuremath{\Rightarrow}\coqdocvar{H}; \coqdoctac{split}.\coqdoceol
\coqdocnoindent
\coqdoctac{by} \coqdoctac{apply}: \coqdocvar{leqnn}.\coqdoceol
\coqdocnoindent
\coqdoctac{by} \coqdoctac{rewrite} \coqdocvar{ltn\_neqAle} \coqdoctac{in} \coqdocvar{H}; \coqdoctac{case}/\coqdocvar{andP}: \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}


The key advantage we got out of using the custom rewriting rule,
defined as an indexed datatype family is lifting the need to prove \textit{by
induction} a statement, which one would intuitively prove by means of
\textit{case analysis}. In fact, all inductive reasoning was conveniently
``sealed'' by the proof of \coqdoclemma{leqP} and the lemmas it made use of, so just
the tailored ``truth table''-like interface for case analysis was given
to the client.


We invite the reader to exercise in using the custom rewriting rules
by proving a series of properties of \coqdocdefinition{maxn}.


\begin{exercise}\label{ex:maxn-props} 


Prove the following lemmas about \coqdocdefinition{maxn}.


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{max\_l} \coqdocvar{m} \coqdocvar{n}: \coqdocvar{n} \ensuremath{\le} \coqdocvar{m} \ensuremath{\rightarrow} \coqdocvar{maxn} \coqdocvar{m} \coqdocvar{n} = \coqdocvar{m}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{succ\_max\_distr} \coqdocvar{n} \coqdocvar{m} : (\coqdocvar{maxn} \coqdocvar{n} \coqdocvar{m}).+1 = \coqdocvar{maxn} (\coqdocvar{n}.+1) (\coqdocvar{m}.+1).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{plus\_max\_distr\_l} \coqdocvar{m} \coqdocvar{n} \coqdocvar{p}: \coqdocvar{maxn} (\coqdocvar{p} + \coqdocvar{n}) (\coqdocvar{p} + \coqdocvar{m}) = \coqdocvar{p} + \coqdocvar{maxn} \coqdocvar{n} \coqdocvar{m}.\coqdoceol
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}


\hint It might be useful to employ the lemmas \coqdoclemma{ltnNge}, \coqdoclemma{leqNgt},
 \coqdoclemma{ltnS} and similar from Ssreflect's \coqdoclibrary{ssrnat} \ssrm{ssrnat}
 module. Use the \coqdockw{Search} command to find propositions that might help
 you to deal with the goal.


\hint Forward-style reasoning via \coqdocvar{\texttt{\emph{suff}}} and \coqdocvar{\texttt{\emph{have}}} might be more
 intuitive.


\hint A hypothesis of the shape \coqdocvar{H}: \coqdocvariable{n} < \coqdocvariable{m} is a syntactic sugar for
 \coqdocvar{H}: \coqdocvariable{n} < \coqdocvariable{m} = \coqdocconstructor{true}, since \coqdocvariable{n} < \coqdocvariable{m} in fact has type \coqdocinductive{bool}, as will be
 explained in Chapter~\ref{ch:boolrefl}.



\end{exercise}



We conclude this section and the chapter by showing an instance of a
more sophisticated custom rewriting rule, which now encodes a
three-variant truth table for the ordering relations on natural
numbers.


\ssrd{nat\_rels}


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdocvar{nat\_rels} \coqdocvar{m} \coqdocvar{n} : \coqdocvar{bool} \ensuremath{\rightarrow} \coqdocvar{bool} \ensuremath{\rightarrow} \coqdocvar{bool} \ensuremath{\rightarrow} \coqdockw{Set} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{CompareNatLt} \coqdockw{\texttt{\emph{of}}} \coqdocvar{m} < \coqdocvar{n} : \coqdocvar{nat\_rels} \coqdocvar{m} \coqdocvar{n} \coqdocvar{true} \coqdocvar{false} \coqdocvar{false}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{CompareNatGt} \coqdockw{\texttt{\emph{of}}} \coqdocvar{m} > \coqdocvar{n} : \coqdocvar{nat\_rels} \coqdocvar{m} \coqdocvar{n} \coqdocvar{false} \coqdocvar{true} \coqdocvar{false}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{CompareNatEq} \coqdockw{\texttt{\emph{of}}} \coqdocvar{m} = \coqdocvar{n} : \coqdocvar{nat\_rels} \coqdocvar{m} \coqdocvar{n} \coqdocvar{false} \coqdocvar{false} \coqdocvar{true}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}


\begin{exercise}[Comparing natural numbers as a rewriting rule]


Prove the following rewriting lemma for \coqdocinductive{nat\_rels}:


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{natrelP} \coqdocvar{m} \coqdocvar{n} : \coqdocvar{nat\_rels} \coqdocvar{m} \coqdocvar{n} (\coqdocvar{m} < \coqdocvar{n}) (\coqdocvar{n} < \coqdocvar{m}) (\coqdocvar{m} == \coqdocvar{n}).\coqdoceol
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}


\end{exercise}


\begin{exercise}


Let us define the minimum function \coqdocdefinition{minn} on natural numbers as
follows:


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{minn} \coqdocvar{m} \coqdocvar{n} := \coqdockw{if} \coqdocvar{m} < \coqdocvar{n} \coqdockw{then} \coqdocvar{m} \coqdockw{else} \coqdocvar{n}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Prove the following lemma about \coqdocvar{minm} and \coqdocdefinition{maxn}:
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{addn\_min\_max} \coqdocvar{m} \coqdocvar{n} : \coqdocvar{minn} \coqdocvar{m} \coqdocvar{n} + \coqdocvar{maxn} \coqdocvar{m} \coqdocvar{n} = \coqdocvar{m} + \coqdocvar{n}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}


\end{exercise}


\begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
